{"version":3,"sources":["assets/path.svg","components/node.js","algorithms/dijkstra.js","components/visualizer.js","App.js","index.js"],"names":["module","exports","Node","props","state","handleMouseDown","bind","handleMouseEnter","handleMouseLeave","nextProps","isClearingWalls","this","setState","isRunning","isEnd","isStart","isWall","mouseDown","isMovingStart","isMovingEnd","row","col","customClass","id","className","onMouseDown","onMouseEnter","onMouseLeave","Component","dijkstra","startNode","finishNode","grid","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","Visualizer","startRow","startCol","endRow","endCol","algorithm","clearBoard","runPathfinder","getShortestPath","toggleIsRunning","clearGrid","getInitialGrid","e","target","split","slice","newGrid","ref","refs","handleMouseUp","visitedNodes","endNode","shortestPath","animate","cur","unshift","i","setTimeout","animateShortestPath","nodeClassName","document","getElementById","distanceToFinishNode","Math","abs","FINISH_NODE_ROW","FINISH_NODE_COL","isNode","onMouseUp","preventDefault","Navbar","bg","variant","expand","Brand","alt","src","pathImg","width","height","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","Button","onClick","map","rowIdx","key","nodeIdx","createNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5963b7a5.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/path.432f50f5.svg\";","import React, { Component } from \"react\";\r\n\r\nclass Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { ...props };\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n  }\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (nextProps.isClearingWalls) {\r\n      this.setState({\r\n        ...nextProps,\r\n      });\r\n    }\r\n  }\r\n\r\n  handleMouseDown() {\r\n    if (this.props.isRunning) return;\r\n    if (!(this.state.isEnd || this.state.isStart)) {\r\n      this.setState({\r\n        isWall: !this.state.isWall,\r\n      });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter() {\r\n    if (this.props.isRunning) return;\r\n    if (this.props.mouseDown) {\r\n      if (this.props.isMovingStart && !this.state.isEnd) {\r\n        this.setState({\r\n          isStart: true,\r\n          isWall: false,\r\n        });\r\n      } else if (this.props.isMovingEnd && !this.state.isStart) {\r\n        this.setState({\r\n          isEnd: true,\r\n          isWall: false,\r\n        });\r\n      } else {\r\n        this.handleMouseDown();\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.props.isRunning) return;\r\n    if (this.props.isMovingStart) {\r\n      this.setState({\r\n        isStart: false,\r\n      });\r\n    }\r\n\r\n    if (this.props.isMovingEnd) {\r\n      this.setState({\r\n        isEnd: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { row, col, isEnd, isStart, isWall } = this.state;\r\n\r\n    const customClass = isEnd\r\n      ? \"node-end\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${customClass}`}\r\n        onMouseDown={this.handleMouseDown}\r\n        onMouseEnter={this.handleMouseEnter}\r\n        onMouseLeave={this.handleMouseLeave}\r\n      ></td>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","export default function dijkstra(startNode, finishNode, grid) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    // get the closest nodes\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    // Skip the wall nodes\r\n    if (closestNode.isWall) continue;\r\n\r\n    // Return the visited nodes if we are trapped by wall\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // Return the visited nodes if we find the target node\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","import React, { Component } from \"react\";\nimport Node from \"./node\";\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\nimport dijkstra from \"../algorithms/dijkstra\";\nimport pathImg from \"../assets/path.svg\";\n\n// Starting with a predefined start and end node\n\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 15;\nconst END_NODE_ROW = 10;\nconst END_NODE_COL = 30;\n\nclass Visualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseDown: false,\n      startRow: START_NODE_ROW,\n      startCol: START_NODE_COL,\n      endRow: END_NODE_ROW,\n      endCol: END_NODE_COL,\n      algorithm: \"Dijkstra\",\n      isRunning: false,\n      isClearingWalls: false,\n      isMovingStart: false,\n      isMovingEnd: false,\n    };\n\n    this.clearBoard = this.clearBoard.bind(this);\n    this.runPathfinder = this.runPathfinder.bind(this);\n    this.getShortestPath = this.getShortestPath.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n    this.clearGrid = this.clearGrid.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  toggleIsRunning() {\n    this.setState({ isRunning: !this.state.isRunning });\n  }\n\n  handleMouseDown(e) {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    const [row, col] = e.target.id.split(\"-\").slice(1);\n    if (row == this.state.startRow && col == this.state.startCol) {\n      this.setState({\n        isMovingStart: true,\n      });\n    }\n\n    if (row == this.state.endRow && col == this.state.endCol) {\n      this.setState({\n        isMovingEnd: true,\n      });\n    }\n    this.setState({ mouseDown: true, isClearingWalls: false });\n  }\n\n  handleMouseUp() {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    this.setState({\n      mouseDown: false,\n      isClearingWalls: false,\n      isMovingStart: false,\n      isMovingEnd: false,\n    });\n\n    let startRow = this.state.startRow,\n      startCol = this.state.startCol,\n      endRow = this.state.endRow,\n      endCol = this.state.endCol;\n\n    const newGrid = this.state.grid.slice();\n    for (let ref in this.refs) {\n      const { row, col, isStart, isEnd } = this.refs[ref].state;\n      newGrid[row][col] = this.refs[ref].state;\n      startRow = isStart ? row : startRow;\n      startCol = isStart ? col : startCol;\n      endRow = isEnd ? row : endRow;\n      endCol = isEnd ? col : endCol;\n    }\n\n    this.setState({\n      grid: newGrid,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n    });\n  }\n\n  handleMouseLeave() {\n    if (this.state.isRunning) return;\n    if (this.state.mouseDown) {\n      this.handleMouseUp();\n    }\n  }\n\n  clearBoard() {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    const { startRow, startCol, endRow, endCol, isRunning } = this.state;\n    const newGrid = getInitialGrid(startRow, startCol, endRow, endCol);\n    this.setState({ isClearingWalls: true, grid: newGrid });\n  }\n\n  runPathfinder() {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    this.toggleIsRunning();\n    const { algorithm, startRow, startCol, endRow, endCol, grid } = this.state;\n    const startNode = grid[startRow][startCol],\n      endNode = grid[endRow][endCol];\n    let visitedNodes;\n\n    switch (algorithm) {\n      case \"Dijkstra\":\n        visitedNodes = dijkstra(startNode, endNode, grid);\n        break;\n      default:\n    }\n\n    const shortestPath = this.getShortestPath(endNode);\n    shortestPath.push(\"end\");\n    this.animate(visitedNodes, shortestPath);\n  }\n\n  getShortestPath(endNode) {\n    const shortestPath = [];\n    let cur = endNode;\n    while (cur !== null) {\n      shortestPath.unshift(cur);\n      cur = cur.previousNode;\n    }\n    return shortestPath;\n  }\n\n  animate(visitedNodes, shortestPath) {\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          this.animateShortestPath(shortestPath);\n        }, 5 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodes[i];\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className;\n        if (\n          nodeClassName !== \"node node-start\" &&\n          nodeClassName !== \"node node-end\"\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 5 * i);\n    }\n  }\n\n  animateShortestPath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      if (shortestPath[i] === \"end\") {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 25);\n      } else {\n        setTimeout(() => {\n          const node = shortestPath[i];\n          const nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node node-start\" &&\n            nodeClassName !== \"node node-end\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node node-shortest-path\";\n          }\n        }, i * 20);\n      }\n    }\n  }\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node node-start\" &&\n            nodeClassName !== \"node node-end\" &&\n            nodeClassName !== \"node node-wall\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node\";\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n          if (nodeClassName === \"node node-end\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n            node.previousNode = null;\n            node.distance = Infinity;\n          }\n          if (nodeClassName === \"node node-start\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  render() {\n    const {\n      grid,\n      mouseDown,\n      isClearingWalls,\n      isMovingStart,\n      isMovingEnd,\n      isRunning,\n    } = this.state;\n\n    return (\n      <div\n        onMouseUp={(e) => {\n          e.preventDefault();\n          this.handleMouseUp();\n        }}\n        onMouseDown={(e) => {\n          e.preventDefault();\n          this.handleMouseDown(e);\n        }}\n        onMouseLeave={(e) => {\n          e.preventDefault();\n          this.handleMouseLeave();\n        }}\n      >\n        <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\">\n          <Navbar.Brand>\n            <img\n              alt=\"\"\n              src={pathImg}\n              width=\"30\"\n              height=\"30\"\n              className=\"d-inline-block align-top\"\n            />{\" \"}\n            Pathfinding visualizer\n          </Navbar.Brand>\n          <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n          <Navbar.Collapse id=\"basic-navbar-nav\">\n            <Nav className=\"mr-auto\">\n              <NavDropdown\n                variant=\"Info\"\n                title=\"Algorithm\"\n                id=\"basic-nav-dropdown\"\n              >\n                <NavDropdown.Item>Dijkstra's</NavDropdown.Item>\n                <NavDropdown.Item>Depth-first search</NavDropdown.Item>\n                <NavDropdown.Item>Breadth-first search</NavDropdown.Item>\n                <NavDropdown.Item>A*</NavDropdown.Item>\n              </NavDropdown>\n\n              <div className=\"navbar-buttons\">\n                <Button variant=\"success\" onClick={this.runPathfinder}>\n                  Visualize {this.state.algorithm}\n                </Button>\n                <Button onClick={this.clearBoard} variant=\"outline-danger\">\n                  Clear walls and board\n                </Button>\n\n                <Button onClick={this.clearGrid} variant=\"outline-warning\">\n                  Clear board\n                </Button>\n              </div>\n            </Nav>\n          </Navbar.Collapse>\n        </Navbar>\n\n        <table className=\"grid\">\n          <tbody>\n            {grid.map((row, rowIdx) => {\n              return (\n                <tr key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const {\n                      row,\n                      col,\n                      isEnd,\n                      isStart,\n                      isWall,\n                      isVisited,\n                      distance,\n                      previousNode,\n                    } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        row={row}\n                        col={col}\n                        isEnd={isEnd}\n                        isStart={isStart}\n                        isWall={isWall}\n                        isVisited={isVisited}\n                        mouseDown={mouseDown}\n                        distance={distance}\n                        previousNode={previousNode}\n                        ref={row + \":\" + col}\n                        isClearingWalls={isClearingWalls}\n                        isMovingStart={isMovingStart}\n                        isMovingEnd={isMovingEnd}\n                        isRunning={isRunning}\n                      ></Node>\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\n\n// Creating an initial grid\nconst getInitialGrid = (startRow, startCol, endRow, endCol) => {\n  const grid = [];\n\n  for (let row = 0; row < 25; row++) {\n    const cur = [];\n\n    for (let col = 0; col < 70; col++) {\n      cur.push(createNode(row, col, startRow, startCol, endRow, endCol));\n    }\n\n    grid.push(cur);\n  }\n  return grid;\n};\n\n// Creating each node\nconst createNode = (row, col, startRow, startCol, endRow, endCol) => {\n  let node = {\n    row,\n    col,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isEnd: row === END_NODE_ROW && col === END_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    mouseDown: false,\n  };\n\n  if (typeof startRow !== \"undefined\") {\n    node.isStart = row === startRow && col === startCol;\n    node.isEnd = row === endRow && col === endCol;\n  }\n\n  return node;\n};\n\nexport default Visualizer;\n","import React from \"react\";\r\nimport \"./css/style.css\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport Visualizer from \"./components/visualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Visualizer />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}