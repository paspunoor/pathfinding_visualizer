{"version":3,"sources":["assets/path.svg","components/node.js","algorithms/dijkstra.js","algorithms/astar.js","components/visualizer.js","algorithms/dfs.js","algorithms/bfs.js","App.js","index.js"],"names":["module","exports","Node","props","state","handleMouseDown","bind","handleMouseEnter","handleMouseLeave","nextProps","isClearingWalls","this","setState","isRunning","isEnd","isStart","isWall","mouseDown","isMovingStart","isMovingEnd","row","col","customClass","id","className","onMouseDown","onMouseEnter","onMouseLeave","Component","dijkstra","startNode","finishNode","grid","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","astar","endNode","distanceToFinishNode","Visualizer","startRow","startCol","endRow","endCol","algorithm","clearBoard","runPathfinder","getShortestPath","toggleIsRunning","clearGrid","handleSelect","getInitialGrid","createNode","eventKey","e","target","split","slice","newGrid","ref","refs","handleMouseUp","cur","visitedNodes","nextNodesStack","currentNode","pop","nextNode","dfs","bfs","shortestPath","animate","unshift","i","setTimeout","animateShortestPath","nodeClassName","document","getElementById","isNode","algo","onMouseUp","preventDefault","Navbar","bg","variant","expand","Brand","alt","src","pathImg","width","height","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","onSelect","Item","Button","onClick","map","rowIdx","key","nodeIdx","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ae459366.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/path.432f50f5.svg\";","import React, { Component } from \"react\";\r\n\r\nclass Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { ...props };\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n  }\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (nextProps.isClearingWalls) {\r\n      this.setState({\r\n        ...nextProps,\r\n      });\r\n    }\r\n  }\r\n\r\n  handleMouseDown() {\r\n    if (this.props.isRunning) return;\r\n    if (!(this.state.isEnd || this.state.isStart)) {\r\n      this.setState({\r\n        isWall: !this.state.isWall,\r\n      });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter() {\r\n    if (this.props.isRunning) return;\r\n    if (this.props.mouseDown) {\r\n      if (this.props.isMovingStart && !this.state.isEnd) {\r\n        this.setState({\r\n          isStart: true,\r\n          isWall: false,\r\n        });\r\n      } else if (this.props.isMovingEnd && !this.state.isStart) {\r\n        this.setState({\r\n          isEnd: true,\r\n          isWall: false,\r\n        });\r\n      } else {\r\n        this.handleMouseDown();\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.props.isRunning) return;\r\n    if (this.props.isMovingStart) {\r\n      this.setState({\r\n        isStart: false,\r\n      });\r\n    }\r\n\r\n    if (this.props.isMovingEnd) {\r\n      this.setState({\r\n        isEnd: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { row, col, isEnd, isStart, isWall } = this.state;\r\n\r\n    const customClass = isEnd\r\n      ? \"node-end\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${customClass}`}\r\n        onMouseDown={this.handleMouseDown}\r\n        onMouseEnter={this.handleMouseEnter}\r\n        onMouseLeave={this.handleMouseLeave}\r\n      ></td>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","export default function dijkstra(startNode, finishNode, grid) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    // get the closest nodes\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    // Skip the wall nodes\r\n    if (closestNode.isWall) continue;\r\n\r\n    // Return the visited nodes if we are trapped by wall\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // Return the visited nodes if we find the target node\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","export default function astar(startNode, endNode, grid) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n\n    if (!closestNode.isWall) {\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === endNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n","import React, { Component } from \"react\";\nimport Node from \"./node\";\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\nimport dijkstra from \"../algorithms/dijkstra\";\nimport astar from \"../algorithms/astar\";\nimport dfs from \"../algorithms/dfs\";\nimport bfs from \"../algorithms/bfs\";\nimport pathImg from \"../assets/path.svg\";\n\n// Starting with a predefined start and end node\n\nclass Visualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseDown: false,\n      startRow: 5,\n      startCol: 15,\n      endRow: 15,\n      endCol: 30,\n      algorithm: \"1\",\n      isRunning: false,\n      isClearingWalls: false,\n      isMovingStart: false,\n      isMovingEnd: false,\n    };\n\n    this.clearBoard = this.clearBoard.bind(this);\n    this.runPathfinder = this.runPathfinder.bind(this);\n    this.getShortestPath = this.getShortestPath.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n    this.clearGrid = this.clearGrid.bind(this);\n    this.handleSelect = this.handleSelect.bind(this);\n    this.getInitialGrid = this.getInitialGrid.bind(this);\n    this.createNode = this.createNode.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n  }\n\n  toggleIsRunning() {\n    this.setState({ isRunning: !this.state.isRunning });\n  }\n\n  handleSelect(eventKey) {\n    this.setState({\n      algorithm: eventKey,\n    });\n  }\n\n  handleMouseDown(e) {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    const [row, col] = e.target.id.split(\"-\").slice(1);\n    if (row == this.state.startRow && col == this.state.startCol) {\n      this.setState({\n        isMovingStart: true,\n      });\n    }\n\n    if (row == this.state.endRow && col == this.state.endCol) {\n      this.setState({\n        isMovingEnd: true,\n      });\n    }\n    this.setState({ mouseDown: true, isClearingWalls: false });\n  }\n\n  handleMouseUp() {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    this.setState({\n      mouseDown: false,\n      isClearingWalls: false,\n      isMovingStart: false,\n      isMovingEnd: false,\n    });\n\n    let startRow = this.state.startRow,\n      startCol = this.state.startCol,\n      endRow = this.state.endRow,\n      endCol = this.state.endCol;\n\n    const newGrid = this.state.grid.slice();\n    for (let ref in this.refs) {\n      const { row, col, isStart, isEnd } = this.refs[ref].state;\n      newGrid[row][col] = this.refs[ref].state;\n      startRow = isStart ? row : startRow;\n      startCol = isStart ? col : startCol;\n      endRow = isEnd ? row : endRow;\n      endCol = isEnd ? col : endCol;\n    }\n\n    this.setState({\n      grid: newGrid,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n    });\n  }\n\n  handleMouseLeave() {\n    if (this.state.isRunning) return;\n    if (this.state.mouseDown) {\n      this.handleMouseUp();\n    }\n  }\n\n  // Creating an initial grid\n  getInitialGrid() {\n    const grid = [];\n\n    for (let row = 0; row < 20; row++) {\n      const cur = [];\n\n      for (let col = 0; col < 50; col++) {\n        cur.push(this.createNode(row, col));\n      }\n\n      grid.push(cur);\n    }\n    return grid;\n  }\n\n  // Creating each node\n  createNode(row, col) {\n    const { startRow, startCol, endRow, endCol } = this.state;\n    let node = {\n      row,\n      col,\n      isStart: row === startRow && col === startCol,\n      isEnd: row === endRow && col === endCol,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      mouseDown: false,\n      distanceToFinishNode: (endRow - row) ** 2 + (endCol - col) ** 2,\n    };\n\n    if (typeof startRow !== \"undefined\") {\n      node.isStart = row === startRow && col === startCol;\n      node.isEnd = row === endRow && col === endCol;\n    }\n\n    return node;\n  }\n\n  clearBoard() {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    const { startRow, startCol, endRow, endCol, isRunning } = this.state;\n    const newGrid = this.getInitialGrid();\n    this.setState({ isClearingWalls: true, grid: newGrid });\n  }\n\n  runPathfinder() {\n    if (this.state.isRunning) return;\n    this.clearGrid();\n    this.toggleIsRunning();\n    const { algorithm, startRow, startCol, endRow, endCol, grid } = this.state;\n    const startNode = grid[startRow][startCol],\n      endNode = grid[endRow][endCol];\n    let visitedNodes;\n\n    switch (algorithm) {\n      case \"1\":\n        visitedNodes = dijkstra(startNode, endNode, grid);\n        break;\n      case \"2\":\n        visitedNodes = astar(startNode, endNode, grid);\n        break;\n      case \"3\":\n        visitedNodes = dfs(startNode, endNode, grid);\n        break;\n      case \"4\":\n        visitedNodes = bfs(startNode, endNode, grid);\n        break;\n      default:\n    }\n\n    const shortestPath = this.getShortestPath(endNode);\n    shortestPath.push(\"end\");\n    this.animate(visitedNodes, shortestPath);\n  }\n\n  getShortestPath(endNode) {\n    const shortestPath = [];\n    let cur = endNode;\n    while (cur !== null) {\n      shortestPath.unshift(cur);\n      cur = cur.previousNode;\n    }\n    return shortestPath;\n  }\n\n  animate(visitedNodes, shortestPath) {\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          this.animateShortestPath(shortestPath);\n        }, 5 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodes[i];\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className;\n        if (\n          nodeClassName !== \"node node-start\" &&\n          nodeClassName !== \"node node-end\"\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 5 * i);\n    }\n  }\n\n  animateShortestPath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      if (shortestPath[i] === \"end\") {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 40);\n      } else {\n        setTimeout(() => {\n          const node = shortestPath[i];\n          const nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node node-start\" &&\n            nodeClassName !== \"node node-end\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node node-shortest-path\";\n          }\n        }, i * 30);\n      }\n    }\n  }\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const { startRow, startCol, endRow, endCol } = this.state;\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node node-start\" &&\n            nodeClassName !== \"node node-end\" &&\n            nodeClassName !== \"node node-wall\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node\";\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              (this.state.endRow - node.row) ** 2 +\n              (this.state.endCol - node.col) ** 2;\n          }\n          if (nodeClassName === \"node node-end\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n            node.previousNode = null;\n            node.distance = Infinity;\n          }\n          if (nodeClassName === \"node node-start\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              (this.state.endRow - node.row) ** 2 +\n              (this.state.endCol - node.col) ** 2;\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  render() {\n    const {\n      grid,\n      mouseDown,\n      isClearingWalls,\n      isMovingStart,\n      isMovingEnd,\n      isRunning,\n      algorithm,\n    } = this.state;\n\n    const algoKeys = {\n      \"1\": \"Dijkstra's\",\n      \"2\": \"A-star\",\n      \"3\": \"Depth-first search\",\n      \"4\": \"Breadth-first search\",\n    };\n\n    const algo = algoKeys[algorithm];\n\n    return (\n      <div\n        onMouseUp={(e) => {\n          e.preventDefault();\n          this.handleMouseUp();\n        }}\n        onMouseDown={(e) => {\n          e.preventDefault();\n          this.handleMouseDown(e);\n        }}\n        onMouseLeave={(e) => {\n          e.preventDefault();\n          this.handleMouseLeave();\n        }}\n      >\n        <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\">\n          <Navbar.Brand>\n            <img\n              alt=\"\"\n              src={pathImg}\n              width=\"30\"\n              height=\"30\"\n              className=\"d-inline-block align-top\"\n            />{\" \"}\n            Pathfinding algorithm visualizer\n          </Navbar.Brand>\n          <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n          <Navbar.Collapse id=\"basic-navbar-nav\">\n            <Nav className=\"mr-auto\">\n              <NavDropdown\n                variant=\"Info\"\n                title=\"Algorithm\"\n                id=\"basic-nav-dropdown\"\n                onSelect={(eventKey) => {\n                  this.handleSelect(eventKey);\n                }}\n              >\n                <NavDropdown.Item eventKey=\"1\">Dijkstra's</NavDropdown.Item>\n                <NavDropdown.Item eventKey=\"2\">A*</NavDropdown.Item>\n                <NavDropdown.Item eventKey=\"3\">\n                  Depth-first search\n                </NavDropdown.Item>\n                <NavDropdown.Item eventKey=\"4\">\n                  Breadth-first search\n                </NavDropdown.Item>\n              </NavDropdown>\n\n              <Button variant=\"info\" onClick={this.runPathfinder}>\n                Run -> {algo}\n              </Button>\n              <Button onClick={this.clearBoard} variant=\"outline-danger\">\n                Clear walls and board\n              </Button>\n\n              <Button onClick={this.clearGrid} variant=\"outline-warning\">\n                Clear board\n              </Button>\n            </Nav>\n          </Navbar.Collapse>\n        </Navbar>\n        <table className=\"grid\">\n          <tbody>\n            {grid.map((row, rowIdx) => {\n              return (\n                <tr key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const {\n                      row,\n                      col,\n                      isEnd,\n                      isStart,\n                      isWall,\n                      isVisited,\n                      distance,\n                      previousNode,\n                    } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        row={row}\n                        col={col}\n                        isEnd={isEnd}\n                        isStart={isStart}\n                        isWall={isWall}\n                        isVisited={isVisited}\n                        mouseDown={mouseDown}\n                        distance={distance}\n                        previousNode={previousNode}\n                        ref={row + \":\" + col}\n                        isClearingWalls={isClearingWalls}\n                        isMovingStart={isMovingStart}\n                        isMovingEnd={isMovingEnd}\n                        isRunning={isRunning}\n                      ></Node>\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\n\nexport default Visualizer;\n","export default function dfs(startNode, finishNode, grid) {\n  const visitedNodesInOrder = [];\n  const nextNodesStack = [];\n  nextNodesStack.push(startNode);\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.pop();\n\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    if (\n      !currentNode.isWall &&\n      (currentNode.isStart || !currentNode.isVisited)\n    ) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}\n","export default function bfs(startNode, finishNode, grid) {\n  const visitedNodesInOrder = [];\n  let nextNodesStack = [startNode];\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    if (\n      !currentNode.isWall &&\n      (currentNode.isStart || !currentNode.isVisited)\n    ) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n  // return visitedNodesInOrder;\n}\n","import React from \"react\";\r\nimport \"./css/style.css\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport Visualizer from \"./components/visualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Visualizer />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}